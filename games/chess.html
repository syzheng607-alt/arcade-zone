<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å›½é™…è±¡æ£‹ - åœ¨çº¿å¯¹æˆ˜ï¼ˆå«AIï¼‰</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body { display: flex; flex-direction: column; align-items: center; min-height: 100vh; padding: 24px; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Helvetica Neue', Arial, 'Noto Sans', 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', sans-serif; background: radial-gradient(1200px 600px at 50% -10%, #1f2a44, #0f172a); color: #e5e7eb; }
        h1 { margin: 6px 0 2px; font-weight: 700; letter-spacing: 0.5px; }
        .subtitle { color: #9ca3af; margin-bottom: 18px; }
        .container { display: grid; grid-template-columns: 640px 320px; gap: 24px; width: 100%; max-width: 1040px; }
        .board { width: 640px; height: 640px; display: grid; grid-template-columns: repeat(8, 1fr); grid-template-rows: repeat(8, 1fr); border-radius: 10px; overflow: hidden; box-shadow: 0 12px 40px rgba(0,0,0,0.5); }
        .sq { display: flex; align-items: center; justify-content: center; user-select: none; position: relative; }
        .light { background: #f0d9b5; }
        .dark { background: #b58863; }
        .mark.valid::after { content: ""; position: absolute; width: 22%; height: 22%; border-radius: 999px; background: rgba(0,0,0,0.25); }
        .mark.capture::after { content: ""; position: absolute; width: 78%; height: 78%; border-radius: 999px; border: 4px solid rgba(255, 64, 64, 0.5); }
        .sq.selected { outline: 4px solid rgba(59,130,246,0.8); outline-offset: -4px; }
        .sq.check { outline: 6px solid rgba(239,68,68,0.85); outline-offset: -6px; }
        .side { background: rgba(15,23,42,0.6); border: 1px solid rgba(255,255,255,0.06); border-radius: 12px; padding: 16px; height: 640px; overflow: hidden; display: flex; flex-direction: column; gap: 12px; }
        .row { display: flex; gap: 8px; align-items: center; }
        .row > label { width: 74px; color: #cbd5e1; font-size: 14px; }
        select, button { background: rgba(255,255,255,0.06); color: #e5e7eb; border: 1px solid rgba(255,255,255,0.12); border-radius: 8px; padding: 8px 10px; }
        button { cursor: pointer; }
        button:hover { background: rgba(255,255,255,0.10); }
        .status { background: rgba(255,255,255,0.04); border: 1px solid rgba(255,255,255,0.08); border-radius: 8px; padding: 10px; min-height: 44px; display: flex; align-items: center; font-size: 14px; color: #cbd5e1; }
        .history { flex: 1; overflow: auto; background: rgba(255,255,255,0.04); border: 1px solid rgba(255,255,255,0.08); border-radius: 8px; padding: 10px; }
        .history h3 { font-size: 14px; color: #94a3b8; margin-bottom: 8px; }
        .list { display: grid; grid-template-columns: repeat(2, minmax(0, 1fr)); gap: 6px 8px; font-size: 14px; }
        .promo-mask { position: fixed; inset: 0; background: rgba(0,0,0,0.55); display: none; place-items: center; z-index: 20; }
        .promo { background: #0b1220; border: 1px solid rgba(255,255,255,0.08); border-radius: 12px; padding: 16px 18px; display: flex; flex-direction: column; gap: 10px; align-items: center; }
        .promo h4 { margin: 0; color: #e5e7eb; }
        .promo .choices { display: flex; gap: 16px; }
        .promo .choice { font-size: 40px; cursor: pointer; }
        
        /* Game Over Modal */
        .game-over-modal {
            display: none;
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.85);
            z-index: 9999;
            align-items: center;
            justify-content: center;
        }
        .game-over-content {
            background: linear-gradient(135deg, #1a4d2e 0%, #0a0a0a 100%);
            border: 3px solid #ff6b35;
            border-radius: 16px;
            padding: 40px;
            text-align: center;
            max-width: 500px;
            animation: modalSlideIn 0.3s ease-out;
        }
        @keyframes modalSlideIn {
            from { transform: translateY(-50px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        .game-over-content h2 {
            font-size: 48px;
            margin: 0 0 20px 0;
        }
        .game-over-content p {
            font-size: 24px;
            margin: 10px 0;
            color: #e5e7eb;
        }
        .game-over-content button {
            margin-top: 30px;
            padding: 12px 32px;
            font-size: 18px;
            background: #ff6b35;
            border: none;
            border-radius: 8px;
            color: white;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
        }
        .game-over-content button:hover {
            background: #e55a2b;
            transform: scale(1.05);
        }
        
        /* å¹³æ¿é€‚é… */
        @media (max-width: 1024px) { 
            .container { 
                grid-template-columns: 1fr; 
                justify-items: center; 
                max-width: 100%;
                padding: 0 12px;
            } 
            .side { 
                width: 100%; 
                max-width: 640px; 
                height: auto; 
            } 
        }
        
        /* æ‰‹æœºé€‚é… */
        @media (max-width: 768px) {
            body {
                padding: 12px 8px;
            }
            h1 {
                font-size: 24px;
                text-align: center;
            }
            .subtitle {
                font-size: 14px;
                text-align: center;
                margin-bottom: 12px;
            }
            .container {
                grid-template-columns: 1fr;
                gap: 16px;
                padding: 0;
                width: 100%;
            }
            .board {
                width: min(calc(100vw - 16px), 500px);
                height: min(calc(100vw - 16px), 500px);
                margin: 0 auto;
            }
            .side {
                width: 100%;
                max-width: min(calc(100vw - 16px), 500px);
                height: auto;
                margin: 0 auto;
            }
            .row {
                flex-wrap: wrap;
            }
            .row > label {
                width: 100%;
                margin-bottom: 4px;
            }
            select, button {
                width: 100%;
                padding: 10px;
                font-size: 16px;
            }
            .history {
                max-height: 200px;
            }
            .game-over-content {
                max-width: calc(100vw - 32px);
                padding: 24px;
            }
            .game-over-content h2 {
                font-size: 36px;
            }
            .game-over-content p {
                font-size: 18px;
            }
            .promo .choice {
                font-size: 36px;
            }
        }
        
        /* å°å±æ‰‹æœºé€‚é… */
        @media (max-width: 480px) {
            body {
                padding: 8px 4px;
            }
            h1 {
                font-size: 20px;
            }
            .subtitle {
                font-size: 12px;
            }
            .board {
                width: calc(100vw - 8px);
                height: calc(100vw - 8px);
            }
            .side {
                width: calc(100vw - 8px);
            }
            .status, .history h3 {
                font-size: 13px;
            }
            .list {
                font-size: 12px;
            }
            .game-over-content {
                padding: 20px;
            }
            .game-over-content h2 {
                font-size: 28px;
            }
            .game-over-content p {
                font-size: 16px;
            }
        }
    </style>
    <script type="module">
        // å¤šè¯­è¨€æ”¯æŒ
        let currentLang = localStorage.getItem('chess-language') || 'en';
        
        const i18n = {
            en: {
                title: 'Chess - Real Stockfish AI',
                subtitle: 'Complete rules Â· Stockfish engine Â· Multiple difficulty levels',
                opponent: 'Opponent',
                opponentAI: 'AI (Stockfish)',
                opponentHuman: 'Local 2 Player',
                yourSide: 'You Play',
                white: 'White',
                black: 'Black',
                difficulty: 'Difficulty',
                veryEasy: 'Very Easy',
                easy: 'Easy',
                medium: 'Medium',
                hard: 'Hard',
                expert: 'Expert',
                depth: 'Depth',
                newGame: 'New Game',
                undo: 'Undo',
                status: 'Status',
                inGame: 'In Game',
                check: 'Check',
                checkmate: 'Checkmate',
                draw: 'Draw',
                turnWhite: 'Turn: White',
                turnBlack: 'Turn: Black',
                moveHistory: 'Move History',
                promotion: 'Promote to:',
                aiThinking: 'AI thinking...',
                aiMoved: 'AI moved',
                gameOverCheckmate: 'ğŸ‰ Game Over!\n\n{winner} wins!\n\n{loser} is checkmated',
                gameOverDraw: 'ğŸ¤ Game Over!\n\nDraw',
                whiteWins: 'White',
                blackWins: 'Black',
                whiteCheckmated: 'White',
                blackCheckmated: 'Black'
            },
            zh: {
                title: 'å›½é™…è±¡æ£‹ - çœŸæ­£çš„ Stockfish AI',
                subtitle: 'å®Œæ•´è§„åˆ™ Â· Stockfish å¼•æ“ Â· å¤šéš¾åº¦çº§åˆ«',
                opponent: 'å¯¹æ‰‹',
                opponentAI: 'AI (Stockfish)',
                opponentHuman: 'æœ¬åœ°åŒäºº',
                yourSide: 'ä½ æ‰§',
                white: 'ç™½',
                black: 'é»‘',
                difficulty: 'éš¾åº¦',
                veryEasy: 'ææ˜“',
                easy: 'ç®€å•',
                medium: 'ä¸­ç­‰',
                hard: 'å›°éš¾',
                expert: 'ä¸“å®¶',
                depth: 'æ·±åº¦',
                newGame: 'æ–°å±€',
                undo: 'æ‚”æ£‹',
                status: 'çŠ¶æ€',
                inGame: 'æ¸¸æˆä¸­',
                check: 'å°†å†›',
                checkmate: 'å°†æ­»',
                draw: 'å’Œæ£‹',
                turnWhite: 'è½®åˆ°: ç™½',
                turnBlack: 'è½®åˆ°: é»‘',
                moveHistory: 'èµ°å­è®°å½•',
                promotion: 'å‡å˜ä¸ºï¼š',
                aiThinking: 'AI æ€è€ƒä¸­...',
                aiMoved: 'AI å·²èµ°æ£‹',
                gameOverCheckmate: 'ğŸ‰ æ¸¸æˆç»“æŸï¼\n\n{winner}è·èƒœï¼\n\n{loser}è¢«å°†æ­»',
                gameOverDraw: 'ğŸ¤ æ¸¸æˆç»“æŸï¼\n\nå’Œæ£‹',
                whiteWins: 'ç™½æ–¹',
                blackWins: 'é»‘æ–¹',
                whiteCheckmated: 'ç™½æ–¹',
                blackCheckmated: 'é»‘æ–¹'
            }
        };
        
        function t(key) {
            return i18n[currentLang][key] || key;
        }
        
        // åŠ¨æ€å¯¼å…¥ chess.js
        async function importWithFallback(candidates) {
            for (const url of candidates) {
                try { return await import(url); } catch (e) { console.warn('å¯¼å…¥å¤±è´¥', url, e); }
            }
            throw new Error('æ‰€æœ‰ CDN å¯¼å…¥å‡å¤±è´¥');
        }
        const chessJsCDN = [
            'https://cdn.jsdelivr.net/npm/chess.js@1.0.0/dist/esm/chess.js',
            'https://esm.sh/chess.js@1.0.0',
            new URL('../lib/chess.mjs', location.href).href,
        ];
        const { Chess } = await importWithFallback(chessJsCDN);

        // ä½¿ç”¨æœ¬åœ° Stockfish.js å¼•æ“
        function createStockfishWorker() {
            console.log('ğŸš€ Initializing Stockfish engine...');
            
            try {
                // ä½¿ç”¨æœ¬åœ°çš„ Stockfish.js
                const stockfishPath = new URL('../lib/stockfish.js', location.href).href;
                console.log('ğŸ“¦ Loading Stockfish from:', stockfishPath);
                
                const stockfish = new Worker(stockfishPath);
                console.log('âœ… Stockfish loaded successfully!');
                
                // æ·»åŠ é”™è¯¯å¤„ç†
                stockfish.onerror = function(error) {
                    console.error('âŒ Stockfish worker error:', error);
                };
                
                return stockfish;
            } catch (e) {
                console.error('âš ï¸ Failed to load Stockfish:', e);
                alert('è­¦å‘Šï¼šæ— æ³•åŠ è½½ Stockfish å¼•æ“ï¼Œå°†ä½¿ç”¨åŸºæœ¬ AIï¼ˆè¾ƒå¼±ï¼‰\n\né”™è¯¯: ' + e.message);
                return createFallbackWorker();
            }
        }
        
        // å¤‡ç”¨ç®€å•AIï¼ˆå¦‚æœStockfishåŠ è½½å¤±è´¥ï¼‰
        function createFallbackWorker() {
            const code = `
                self.onmessage = function(e) {
                    const cmd = e.data;
                    if (cmd === 'uci') {
                        self.postMessage('uciok');
                    } else if (cmd.startsWith('position')) {
                        // å­˜å‚¨ä½ç½®
                    } else if (cmd.startsWith('go')) {
                        // è¿”å›éšæœºèµ°æ³•ï¼ˆéœ€è¦ä»positionä¸­è§£æï¼‰
                        setTimeout(() => {
                            self.postMessage('bestmove e2e4'); // ç®€å•é»˜è®¤èµ°æ³•
                        }, 500);
                    }
                };
            `;
            const blob = new Blob([code], { type: 'application/javascript' });
            return new Worker(URL.createObjectURL(blob));
        }

        // é¡µé¢éª¨æ¶
        const h1 = document.createElement('h1'); h1.id = 'game-title'; h1.textContent = t('title');
        const subtitle = document.createElement('div'); subtitle.id = 'game-subtitle'; subtitle.className = 'subtitle'; subtitle.textContent = t('subtitle');
        const container = document.createElement('div'); container.className = 'container';
        const board = document.createElement('div'); board.className = 'board';
        const side = document.createElement('div'); side.className = 'side';
        document.body.appendChild(h1); document.body.appendChild(subtitle); document.body.appendChild(container);
        container.appendChild(board); container.appendChild(side);
        
        function renderSidePanel() {
        side.innerHTML = ''+
            `<div class="row"><label>${t('opponent')}</label><select id="opponent"><option value="ai" selected>${t('opponentAI')}</option><option value="human">${t('opponentHuman')}</option></select></div>`+
            `<div class="row"><label>${t('yourSide')}</label><select id="side"><option value="w" selected>${t('white')}</option><option value="b">${t('black')}</option></select></div>`+
            `<div class="row"><label>${t('difficulty')}</label><select id="level"><option value="1">${t('veryEasy')}</option><option value="5">${t('easy')}</option><option value="10" selected>${t('medium')}</option><option value="15">${t('hard')}</option><option value="20">${t('expert')}</option></select></div>`+
            `<div class="row"><label>${t('depth')}</label><select id="depth"><option value="5">5</option><option value="10" selected>10</option><option value="15">15</option><option value="20">20</option></select></div>`+
            `<div class="row" style="gap:10px; margin-top:4px;"><button id="new">${t('newGame')}</button><button id="undo">${t('undo')}</button></div>`+
            `<div class="status" id="status">${t('status')}: ${t('inGame')}</div>`+
            `<div class="history"><h3>${t('moveHistory')}</h3><div class="list" id="moves"></div></div>`;
        }
        renderSidePanel();
        
        const promoMask = document.createElement('div'); promoMask.className = 'promo-mask';
        promoMask.innerHTML = `<div class="promo"><h4 id="promo-title">${t('promotion')}</h4><div class="choices">\
            <span class="choice" data-q="q">â™›</span>\
            <span class="choice" data-q="r">â™œ</span>\
            <span class="choice" data-q="b">â™</span>\
            <span class="choice" data-q="n">â™</span>\
        </div></div>`;
        document.body.appendChild(promoMask);
        
        // Game Over Modal
        const gameOverModal = document.createElement('div');
        gameOverModal.className = 'game-over-modal';
        gameOverModal.id = 'game-over-modal';
        gameOverModal.innerHTML = `
            <div class="game-over-content">
                <h2 id="game-over-emoji">ğŸ‰</h2>
                <p id="game-over-title" style="font-size: 32px; font-weight: bold; color: #ff6b35;">Game Over!</p>
                <p id="game-over-message" style="font-size: 24px;"></p>
                <button id="game-over-close" onclick="document.getElementById('game-over-modal').style.display='none'">${currentLang === 'zh' ? 'ç¡®å®š' : 'OK'}</button>
            </div>
        `;
        document.body.appendChild(gameOverModal);
        
        function showGameOver(emoji, title, message) {
            document.getElementById('game-over-emoji').textContent = emoji;
            document.getElementById('game-over-title').textContent = title;
            document.getElementById('game-over-message').textContent = message;
            document.getElementById('game-over-modal').style.display = 'flex';
        }

        // æ£‹å±€ä¸æ¸²æŸ“
        function pieceImageUrl(type, color) {
            const key = (color === 'w' ? type.toUpperCase() : type);
            // ä½¿ç”¨å¤šä¸ª CDN æºï¼Œç¡®ä¿åœ¨å„ç§ç½‘ç»œç¯å¢ƒä¸‹éƒ½èƒ½åŠ è½½
            const cdnBase = [
                'https://cdn.jsdelivr.net/gh/lichess-org/lila@master/public/piece/cburnett/',
                'https://images.chesscomfiles.com/chess-themes/pieces/neo/150/',
                'https://upload.wikimedia.org/wikipedia/commons/'
            ];
            
            const map = {
                // ç™½æ£‹ - ä½¿ç”¨ lichess CDN
                P: `${cdnBase[0]}wP.svg`,
                N: `${cdnBase[0]}wN.svg`,
                B: `${cdnBase[0]}wB.svg`,
                R: `${cdnBase[0]}wR.svg`,
                Q: `${cdnBase[0]}wQ.svg`,
                K: `${cdnBase[0]}wK.svg`,
                // é»‘æ£‹ - ä½¿ç”¨ lichess CDN
                p: `${cdnBase[0]}bP.svg`,
                n: `${cdnBase[0]}bN.svg`,
                b: `${cdnBase[0]}bB.svg`,
                r: `${cdnBase[0]}bR.svg`,
                q: `${cdnBase[0]}bQ.svg`,
                k: `${cdnBase[0]}bK.svg`
            };
            return map[key];
        }
        
        // å¤‡ç”¨ï¼šä½¿ç”¨ Unicode å­—ç¬¦ï¼ˆå¦‚æœå›¾ç‰‡åŠ è½½å¤±è´¥ï¼‰
        function getPieceUnicode(type, color) {
            const symbols = {
                P: 'â™™', N: 'â™˜', B: 'â™—', R: 'â™–', Q: 'â™•', K: 'â™”',
                p: 'â™Ÿ', n: 'â™', b: 'â™', r: 'â™œ', q: 'â™›', k: 'â™š'
            };
            const key = (color === 'w' ? type.toUpperCase() : type);
            return symbols[key];
        }
        const game = new Chess();
        const squares = [];
        for (let r = 0; r < 8; r++) {
            for (let c = 0; c < 8; c++) {
                const sq = document.createElement('div');
                sq.className = 'sq ' + ((r + c) % 2 === 0 ? 'light' : 'dark');
                sq.dataset.r = String(r); sq.dataset.c = String(c);
                board.appendChild(sq); squares.push(sq);
            }
        }
        function rcToSquare(r, c) { return 'abcdefgh'[c] + (8 - r); }
        function squareToRC(sq) { const rank = parseInt(sq[1], 10); return [8 - rank, sq.charCodeAt(0) - 97]; }
        function findKing(color) {
            const b = game.board();
            for (let r = 0; r < 8; r++) for (let c = 0; c < 8; c++) { const p=b[r][c]; if (p && p.type==='k' && p.color===color) return rcToSquare(r,c); }
            return null;
        }
        function render() {
            squares.forEach(s => { s.innerHTML=''; s.classList.remove('selected','mark','valid','capture','check'); });
            for (let r = 0; r < 8; r++) for (let c = 0; c < 8; c++) {
                const name = rcToSquare(r,c); const p = game.get(name);
                if (p) {
                    const img = document.createElement('img');
                    img.src = pieceImageUrl(p.type, p.color);
                    img.alt = p.type + p.color;
                    img.style.width = '86%';
                    img.style.height = '86%';
                    img.style.objectFit = 'contain';
                    
                    // å›¾ç‰‡åŠ è½½å¤±è´¥æ—¶ä½¿ç”¨ Unicode å­—ç¬¦ä½œä¸ºå¤‡ç”¨
                    img.onerror = function() {
                        console.warn('Failed to load piece image:', img.src);
                        const fallback = document.createElement('span');
                        fallback.textContent = getPieceUnicode(p.type, p.color);
                        fallback.style.fontSize = '48px';
                        fallback.style.lineHeight = '1';
                        fallback.style.userSelect = 'none';
                        fallback.style.filter = p.color === 'w' ? 'drop-shadow(0 1px 2px rgba(0,0,0,0.3))' : 'none';
                        this.parentElement.replaceChild(fallback, this);
                    };
                    
                    squares[r*8+c].appendChild(img);
                }
            }
            if (game.inCheck()) { const k = findKing(game.turn()); if (k) { const [kr,kc]=squareToRC(k); squares[kr*8+kc].classList.add('check'); } }
            updateStatus(); renderMoves();
        }
        function renderMoves() {
            const list = document.getElementById('moves'); list.innerHTML='';
            const hist = game.history({ verbose: true });
            for (let i=0;i<hist.length;i+=2) { const w=hist[i], b=hist[i+1];
                const wEl=document.createElement('div'); wEl.textContent = `${i/2+1}. ${w? w.san: ''}`; list.appendChild(wEl);
                const bEl=document.createElement('div'); bEl.textContent = b? b.san: ''; list.appendChild(bEl);
            }
        }

        // äº¤äº’
        let selectedSq = null;
        function clearHighlights(){ squares.forEach(s=>s.classList.remove('selected','mark','valid','capture')); }
        function highlightMoves(from){
            const moves = game.moves({ square: from, verbose: true });
            for (const m of moves){ const [r,c]=squareToRC(m.to); const el = squares[r*8+c]; el.classList.add('mark', m.flags.includes('c') ? 'capture':'valid'); }
        }
        board.addEventListener('click', (e)=>{
            const target = e.target.closest('.sq'); if(!target) return;
            const r=parseInt(target.dataset.r,10), c=parseInt(target.dataset.c,10); const sq = rcToSquare(r,c);
            const opponent = document.getElementById('opponent').value;
            const humanColor = document.getElementById('side').value;
            const humanTurn = opponent==='human' || game.turn()===humanColor;
            if(!humanTurn) return;
            const piece = game.get(sq);
            if(selectedSq===sq){ selectedSq=null; clearHighlights(); return; }
            if(!selectedSq){ if(piece && piece.color===game.turn()){ selectedSq=sq; clearHighlights(); target.classList.add('selected'); highlightMoves(sq);} return; }
            
            // æ£€æŸ¥è¿™æ­¥æ£‹æ˜¯å¦åˆæ³•
            const validMoves = game.moves({ square: selectedSq, verbose: true });
            const isValidMove = validMoves.some(m => m.to === sq);
            if(!isValidMove){ 
                // å¦‚æœä¸æ˜¯åˆæ³•ç§»åŠ¨ï¼Œå–æ¶ˆé€‰æ‹©æˆ–é‡æ–°é€‰æ‹©
                if(piece && piece.color===game.turn()){ 
                    selectedSq=sq; 
                    clearHighlights(); 
                    target.classList.add('selected'); 
                    highlightMoves(sq);
                } else {
                    selectedSq=null; 
                    clearHighlights();
                }
                return; 
            }
            
            // åªæœ‰åœ¨åˆæ³•ç§»åŠ¨çš„æƒ…å†µä¸‹æ‰æ£€æŸ¥æ˜¯å¦éœ€è¦å‡å˜
            const moveInfo = validMoves.find(m => m.to === sq);
            const isPromotion = moveInfo && moveInfo.flags.includes('p');
            if(isPromotion){ showPromotion().then(prom=>{ tryMove(selectedSq,sq,prom); }); } else { tryMove(selectedSq,sq,undefined); }
        });
        function tryMove(from,to,promotion){ const res = game.move({from,to,promotion}); if(res){ selectedSq=null; clearHighlights(); render(); maybeAIMove(); } }
        function showPromotion(){ return new Promise(resolve=>{ promoMask.style.display='grid';
            const onClick=(e)=>{ const el=e.target.closest('.choice'); if(!el) return; const q=el.getAttribute('data-q'); cleanup(); resolve(q); };
            function cleanup(){ promoMask.style.display='none'; promoMask.removeEventListener('click', onClick); }
            promoMask.addEventListener('click', onClick);
        }); }

        // çŠ¶æ€ä¸æŒ‰é’®
        const statusEl = document.getElementById('status');
        let gameEnded = false;
        
        function updateStatus() {
            let statusText = t('status') + ': ';
            
            if (game.isCheckmate()) {
                statusText += t('checkmate');
                const winner = game.turn() === 'w' ? t('blackWins') : t('whiteWins');
                statusEl.textContent = statusText + ` Â· ${winner} wins!`;
                
                // é˜²æ­¢é‡å¤å¼¹çª—
                if (!gameEnded) {
                    gameEnded = true;
                    setTimeout(() => {
                        const loser = game.turn() === 'w' ? t('whiteCheckmated') : t('blackCheckmated');
                        const title = currentLang === 'zh' ? 'æ¸¸æˆç»“æŸï¼' : 'Game Over!';
                        const msg = currentLang === 'zh' 
                            ? `${winner}è·èƒœï¼\n${loser}è¢«å°†æ­»` 
                            : `${winner} wins!\n${loser} is checkmated`;
                        showGameOver('ğŸ‰', title, msg);
                        console.log('âœ… CHECKMATE!', winner, 'wins!');
                    }, 300);
                }
            } else if (game.isDraw()) {
                statusText += t('draw');
                statusEl.textContent = statusText + ' Â· Draw';
                
                if (!gameEnded) {
                    gameEnded = true;
                    setTimeout(() => {
                        const title = currentLang === 'zh' ? 'æ¸¸æˆç»“æŸï¼' : 'Game Over!';
                        const msg = currentLang === 'zh' ? 'å’Œæ£‹ - å¹³å±€' : 'Draw - Stalemate';
                        showGameOver('ğŸ¤', title, msg);
                        console.log('âœ… DRAW!');
                    }, 300);
                }
            } else if (game.inCheck()) {
                statusText += t('check');
                statusEl.textContent = statusText + ` Â· ${game.turn() === 'w' ? t('turnWhite') : t('turnBlack')}`;
            } else {
                statusText += t('inGame');
                statusEl.textContent = statusText + ` Â· ${game.turn() === 'w' ? t('turnWhite') : t('turnBlack')}`;
            }
        }
        document.getElementById('new').onclick = ()=>{ gameEnded = false; game.reset(); render(); maybeAIMove(true); };
        document.getElementById('undo').onclick = ()=>{ game.undo(); game.undo(); render(); };
        document.getElementById('opponent').onchange = ()=>{ render(); maybeAIMove(true); };
        document.getElementById('side').onchange = ()=>{ gameEnded = false; game.reset(); render(); maybeAIMove(true); };

        // Stockfish é›†æˆ
        const engine = createStockfishWorker();
        let engineReady = false;
        
        console.log('ğŸ® Chess engine initialized:', engine ? 'Success' : 'Failed');
        
        engine.onmessage = (ev)=>{
            const line = typeof ev.data === 'string' ? ev.data : String(ev.data);
            console.log('Stockfish:', line);
            
            if (line === 'uciok') {
                engineReady = true;
                console.log('Stockfish engine ready!');
            }
            
            if (line.startsWith('bestmove')) {
                const parts = line.split(' ');
                const mv = parts[1];
                if (mv && mv.length >= 4 && mv !== '(none)') {
                    const from = mv.slice(0, 2);
                    const to = mv.slice(2, 4);
                    const promo = mv[4];
                    console.log('Stockfish move:', from, 'to', to, promo ? 'promote to ' + promo : '');
                    
                    setTimeout(() => {
                            tryMove(from, to, promo);
                        statusEl.textContent = t('status') + ': ' + t('aiMoved');
                    }, 100);
                }
            }
        };
        
        // åˆå§‹åŒ–å¼•æ“
        engine.postMessage('uci');
        
        async function maybeAIMove(force = false) {
            const opponent = document.getElementById('opponent').value;
            const humanColor = document.getElementById('side').value;
            const currentTurn = game.turn();
            
            console.log('maybeAIMove:', { force, opponent, humanColor, currentTurn, gameOver: game.isGameOver() });
            
            if (opponent !== 'ai') return;
            if (game.isGameOver()) return;
            if (!force && currentTurn === humanColor) return;
            if (force && humanColor === 'w' && game.history().length === 0) return;
            
            console.log('ğŸ¤– AI is thinking...');
            statusEl.textContent = t('status') + ': ' + t('aiThinking');
            
            const level = parseInt(document.getElementById('level').value, 10);
            const depth = parseInt(document.getElementById('depth').value, 10);
            const fen = game.fen();
            
            console.log('ğŸ“Š AI Settings:', { level, depth });
            console.log('ğŸ“‹ Position FEN:', fen);
            
            // å‘é€å‘½ä»¤åˆ° Stockfish
            console.log('ğŸ“¤ Sending commands to Stockfish...');
            engine.postMessage('ucinewgame');
            engine.postMessage(`setoption name Skill Level value ${level}`);
            engine.postMessage(`position fen ${fen}`);
            engine.postMessage(`go depth ${depth}`);
            console.log(`âœ… Commands sent: level=${level}, depth=${depth}`);
        }

        // åˆå§‹æ¸²æŸ“
        render();
        setTimeout(() => maybeAIMove(true), 1000);
        
        // ç›‘å¬æ¥è‡ªçˆ¶é¡µé¢çš„è¯­è¨€åˆ‡æ¢æ¶ˆæ¯
        window.addEventListener('message', function(event) {
            if (event.data && event.data.type === 'languageChange') {
                currentLang = event.data.lang;
                localStorage.setItem('chess-language', currentLang);
                
                // æ›´æ–°æ‰€æœ‰æ–‡æœ¬
                document.getElementById('game-title').textContent = t('title');
                document.getElementById('game-subtitle').textContent = t('subtitle');
                document.getElementById('promo-title').textContent = t('promotion');
                document.getElementById('game-over-close').textContent = currentLang === 'zh' ? 'ç¡®å®š' : 'OK';
                
                // é‡æ–°æ¸²æŸ“ä¾§è¾¹æ 
                const savedValues = {
                    opponent: document.getElementById('opponent').value,
                    side: document.getElementById('side').value,
                    level: document.getElementById('level').value,
                    depth: document.getElementById('depth').value
                };
                
                renderSidePanel();
                
                // æ¢å¤é€‰ä¸­çš„å€¼
                document.getElementById('opponent').value = savedValues.opponent;
                document.getElementById('side').value = savedValues.side;
                document.getElementById('level').value = savedValues.level;
                document.getElementById('depth').value = savedValues.depth;
                
                // é‡æ–°ç»‘å®šäº‹ä»¶
                document.getElementById('new').onclick = ()=>{ gameEnded = false; game.reset(); render(); maybeAIMove(true); };
                document.getElementById('undo').onclick = ()=>{ game.undo(); game.undo(); render(); };
                document.getElementById('opponent').onchange = ()=>{ render(); maybeAIMove(true); };
                document.getElementById('side').onchange = ()=>{ gameEnded = false; game.reset(); render(); maybeAIMove(true); };
                
                // æ›´æ–°çŠ¶æ€æ˜¾ç¤º
                updateStatus();
                
                console.log('Language changed to:', currentLang);
            }
        });
        
        // åŒæ­¥çˆ¶é¡µé¢çš„è¯­è¨€è®¾ç½®
        const parentLang = localStorage.getItem('site-language');
        if (parentLang && parentLang !== currentLang) {
            currentLang = parentLang;
            localStorage.setItem('chess-language', currentLang);
        }
    </script>
</head>
<body></body>
</html>
