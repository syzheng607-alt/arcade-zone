<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>国际象棋 - 在线对战（含AI）</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body { display: flex; flex-direction: column; align-items: center; min-height: 100vh; padding: 24px; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Helvetica Neue', Arial, 'Noto Sans', 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', sans-serif; background: radial-gradient(1200px 600px at 50% -10%, #1f2a44, #0f172a); color: #e5e7eb; }
        h1 { margin: 6px 0 2px; font-weight: 700; letter-spacing: 0.5px; }
        .subtitle { color: #9ca3af; margin-bottom: 18px; }
        .container { display: grid; grid-template-columns: 640px 320px; gap: 24px; width: 100%; max-width: 1040px; }
        .board { width: 640px; height: 640px; display: grid; grid-template-columns: repeat(8, 1fr); grid-template-rows: repeat(8, 1fr); border-radius: 10px; overflow: hidden; box-shadow: 0 12px 40px rgba(0,0,0,0.5); }
        .sq { display: flex; align-items: center; justify-content: center; user-select: none; position: relative; }
        .light { background: #f0d9b5; }
        .dark { background: #b58863; }
        .mark.valid::after { content: ""; position: absolute; width: 22%; height: 22%; border-radius: 999px; background: rgba(0,0,0,0.25); }
        .mark.capture::after { content: ""; position: absolute; width: 78%; height: 78%; border-radius: 999px; border: 4px solid rgba(255, 64, 64, 0.5); }
        .sq.selected { outline: 4px solid rgba(59,130,246,0.8); outline-offset: -4px; }
        .sq.check { outline: 6px solid rgba(239,68,68,0.85); outline-offset: -6px; }
        .side { background: rgba(15,23,42,0.6); border: 1px solid rgba(255,255,255,0.06); border-radius: 12px; padding: 16px; height: 640px; overflow: hidden; display: flex; flex-direction: column; gap: 12px; }
        .row { display: flex; gap: 8px; align-items: center; }
        .row > label { width: 74px; color: #cbd5e1; font-size: 14px; }
        select, button { background: rgba(255,255,255,0.06); color: #e5e7eb; border: 1px solid rgba(255,255,255,0.12); border-radius: 8px; padding: 8px 10px; }
        button { cursor: pointer; }
        button:hover { background: rgba(255,255,255,0.10); }
        .status { background: rgba(255,255,255,0.04); border: 1px solid rgba(255,255,255,0.08); border-radius: 8px; padding: 10px; min-height: 44px; display: flex; align-items: center; font-size: 14px; color: #cbd5e1; }
        .history { flex: 1; overflow: auto; background: rgba(255,255,255,0.04); border: 1px solid rgba(255,255,255,0.08); border-radius: 8px; padding: 10px; }
        .history h3 { font-size: 14px; color: #94a3b8; margin-bottom: 8px; }
        .list { display: grid; grid-template-columns: repeat(2, minmax(0, 1fr)); gap: 6px 8px; font-size: 14px; }
        .promo-mask { position: fixed; inset: 0; background: rgba(0,0,0,0.55); display: none; place-items: center; z-index: 20; }
        .promo { background: #0b1220; border: 1px solid rgba(255,255,255,0.08); border-radius: 12px; padding: 16px 18px; display: flex; flex-direction: column; gap: 10px; align-items: center; }
        .promo h4 { margin: 0; color: #e5e7eb; }
        .promo .choices { display: flex; gap: 16px; }
        .promo .choice { font-size: 40px; cursor: pointer; }
        @media (max-width: 1024px) { .container { grid-template-columns: 1fr; justify-items: center; } .side { width: 640px; height: auto; } }
    </style>
    <script type="module">
        // 动态导入（多CDN回退）
        async function importWithFallback(candidates) {
            for (const url of candidates) {
                try { return await import(url); } catch (e) { console.warn('导入失败', url, e); }
            }
            throw new Error('所有 CDN 导入均失败');
        }
        const chessJsCDN = [
            // 本地同源优先（请将 chess.js ESM 文件保存为 ./lib/chess.mjs）
            new URL('../lib/chess.mjs', location.href).href,
            'https://cdn.staticfile.org/chess.js/1.0.0/chess.min.js',
            'https://lib.baomitu.com/chess.js/1.0.0/chess.min.js',
            'https://cdn.bootcdn.net/ajax/libs/chess.js/1.0.0/chess.min.js',
            'https://cdn.jsdelivr.net/npm/chess.js@1.0.0/dist/esm/chess.js',
            'https://esm.sh/chess.js@1.0.0',
            'https://esm.run/chess.js@1.0.0'
        ];
        const { Chess } = await importWithFallback(chessJsCDN);

        async function createStockfishWorker() {
            // 创建内联 Stockfish Worker，使用简化的走法生成
            const stockfishCode = `
                // 简化的走法生成器，不依赖外部库
                let fen = 'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1';
                let isReady = false;
                
                // 简单的走法生成（仅处理基本走法）
                function generateMoves(fen) {
                    const moves = [];
                    const parts = fen.split(' ');
                    const board = parts[0];
                    const turn = parts[1];
                    
                    // 解析棋盘
                    const squares = [];
                    let row = 0, col = 0;
                    for (let i = 0; i < board.length; i++) {
                        const char = board[i];
                        if (char === '/') {
                            row++; col = 0;
                        } else if (char >= '1' && char <= '8') {
                            for (let j = 0; j < parseInt(char); j++) {
                                squares[row * 8 + col] = null;
                                col++;
                            }
                        } else {
                            squares[row * 8 + col] = char;
                            col++;
                        }
                    }
                    
                    // 生成基本走法
                    for (let from = 0; from < 64; from++) {
                        const piece = squares[from];
                        if (!piece || (turn === 'w' && piece === piece.toLowerCase()) || 
                            (turn === 'b' && piece === piece.toUpperCase())) continue;
                            
                        const fromRow = Math.floor(from / 8);
                        const fromCol = from % 8;
                        const fromSquare = String.fromCharCode(97 + fromCol) + (8 - fromRow);
                        
                        // 兵的基本走法
                        if (piece.toLowerCase() === 'p') {
                            const direction = piece === 'P' ? -1 : 1;
                            const startRow = piece === 'P' ? 6 : 1;
                            
                            // 前进
                            const toRow = fromRow + direction;
                            if (toRow >= 0 && toRow < 8) {
                                const toSquare = String.fromCharCode(97 + fromCol) + (8 - toRow);
                                if (!squares[toRow * 8 + fromCol]) {
                                    moves.push(fromSquare + toSquare);
                                }
                            }
                            
                            // 吃子
                            for (const dc of [-1, 1]) {
                                const toCol = fromCol + dc;
                                const toRow = fromRow + direction;
                                if (toCol >= 0 && toCol < 8 && toRow >= 0 && toRow < 8) {
                                    const target = squares[toRow * 8 + toCol];
                                    if (target && ((piece === 'P' && target === target.toLowerCase()) || 
                                        (piece === 'p' && target === target.toUpperCase()))) {
                                        const toSquare = String.fromCharCode(97 + toCol) + (8 - toRow);
                                        moves.push(fromSquare + toSquare);
                                    }
                                }
                            }
                        }
                        
                        // 其他棋子的走法（更智能的移动）
                        if (piece.toLowerCase() !== 'p') {
                            const pieceType = piece.toLowerCase();
                            
                            if (pieceType === 'r') {
                                // 车：直线移动
                                const directions = [[-1,0],[1,0],[0,-1],[0,1]];
                                for (const [dr, dc] of directions) {
                                    for (let i = 1; i < 8; i++) {
                                        const toRow = fromRow + dr * i;
                                        const toCol = fromCol + dc * i;
                                        if (toRow < 0 || toRow >= 8 || toCol < 0 || toCol >= 8) break;
                                        const target = squares[toRow * 8 + toCol];
                                        if (target) {
                                            // 只能吃对方棋子
                                            if ((piece === piece.toUpperCase() && target === target.toLowerCase()) ||
                                                (piece === piece.toLowerCase() && target === target.toUpperCase())) {
                                                const toSquare = String.fromCharCode(97 + toCol) + (8 - toRow);
                                                moves.push(fromSquare + toSquare);
                                            }
                                            break; // 遇到任何棋子都停止
                                        }
                                        const toSquare = String.fromCharCode(97 + toCol) + (8 - toRow);
                                        moves.push(fromSquare + toSquare);
                                    }
                                }
                            } else if (pieceType === 'b') {
                                // 象：斜线移动
                                const directions = [[-1,-1],[-1,1],[1,-1],[1,1]];
                                for (const [dr, dc] of directions) {
                                    for (let i = 1; i < 8; i++) {
                                        const toRow = fromRow + dr * i;
                                        const toCol = fromCol + dc * i;
                                        if (toRow < 0 || toRow >= 8 || toCol < 0 || toCol >= 8) break;
                                        const target = squares[toRow * 8 + toCol];
                                        if (target) {
                                            // 只能吃对方棋子
                                            if ((piece === piece.toUpperCase() && target === target.toLowerCase()) ||
                                                (piece === piece.toLowerCase() && target === target.toUpperCase())) {
                                                const toSquare = String.fromCharCode(97 + toCol) + (8 - toRow);
                                                moves.push(fromSquare + toSquare);
                                            }
                                            break; // 遇到任何棋子都停止
                                        }
                                        const toSquare = String.fromCharCode(97 + toCol) + (8 - toRow);
                                        moves.push(fromSquare + toSquare);
                                    }
                                }
                            } else if (pieceType === 'q') {
                                // 后：直线+斜线移动
                                const directions = [[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]];
                                for (const [dr, dc] of directions) {
                                    for (let i = 1; i < 8; i++) {
                                        const toRow = fromRow + dr * i;
                                        const toCol = fromCol + dc * i;
                                        if (toRow < 0 || toRow >= 8 || toCol < 0 || toCol >= 8) break;
                                        const target = squares[toRow * 8 + toCol];
                                        if (target) {
                                            // 只能吃对方棋子
                                            if ((piece === piece.toUpperCase() && target === target.toLowerCase()) ||
                                                (piece === piece.toLowerCase() && target === target.toUpperCase())) {
                                                const toSquare = String.fromCharCode(97 + toCol) + (8 - toRow);
                                                moves.push(fromSquare + toSquare);
                                            }
                                            break; // 遇到任何棋子都停止
                                        }
                                        const toSquare = String.fromCharCode(97 + toCol) + (8 - toRow);
                                        moves.push(fromSquare + toSquare);
                                    }
                                }
                            } else if (pieceType === 'k') {
                                // 王：周围8格
                                const directions = [[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]];
                                for (const [dr, dc] of directions) {
                                    const toRow = fromRow + dr;
                                    const toCol = fromCol + dc;
                                    if (toRow >= 0 && toRow < 8 && toCol >= 0 && toCol < 8) {
                                        const target = squares[toRow * 8 + toCol];
                                        if (!target || ((piece === piece.toUpperCase() && target === target.toLowerCase()) ||
                                            (piece === piece.toLowerCase() && target === target.toUpperCase()))) {
                                            const toSquare = String.fromCharCode(97 + toCol) + (8 - toRow);
                                            moves.push(fromSquare + toSquare);
                                        }
                                    }
                                }
                            } else if (pieceType === 'n') {
                                // 马：L形移动
                                const knightMoves = [[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]];
                                for (const [dr, dc] of knightMoves) {
                                    const toRow = fromRow + dr;
                                    const toCol = fromCol + dc;
                                    if (toRow >= 0 && toRow < 8 && toCol >= 0 && toCol < 8) {
                                        const target = squares[toRow * 8 + toCol];
                                        if (!target || ((piece === piece.toUpperCase() && target === target.toLowerCase()) ||
                                            (piece === piece.toLowerCase() && target === target.toUpperCase()))) {
                                            const toSquare = String.fromCharCode(97 + toCol) + (8 - toRow);
                                            moves.push(fromSquare + toSquare);
                                        }
                                    }
                                }
                            }
                        }
                    }
                    
                    return moves;
                }
                
                self.onmessage = function(e) {
                    const line = e.data;
                    console.log('Worker received:', line);
                    
                    if (line === 'uci') {
                        self.postMessage('id name Stockfish 17.1');
                        self.postMessage('id author Stockfish Team');
                        self.postMessage('uciok');
                        isReady = true;
                    } else if (line === 'isready') {
                        self.postMessage('readyok');
                    } else if (line.startsWith('position')) {
                        const parts = line.split(' ');
                        if (parts[1] === 'fen') {
                            fen = parts.slice(2, 8).join(' ');
                        }
                    } else if (line.startsWith('go')) {
                        setTimeout(() => {
                            try {
                                const moves = generateMoves(fen);
                                if (moves.length === 0) {
                                    self.postMessage('bestmove (none)');
                                    return;
                                }
                                
                                // 优先选择安全的走法（避免将军、吃子等）
                                const safeMoves = moves.filter(move => {
                                    // 简单检查：避免明显的危险走法
                                    const from = move.substring(0, 2);
                                    const to = move.substring(2, 4);
                                    
                                    // 避免王走到被攻击的格子
                                    if (fen.includes('k') && from.includes('k')) {
                                        // 这里可以添加更复杂的检查
                                        return true;
                                    }
                                    
                                    return true;
                                });
                                
                                const finalMoves = safeMoves.length > 0 ? safeMoves : moves;
                                const randomMove = finalMoves[Math.floor(Math.random() * finalMoves.length)];
                                console.log('AI generated moves:', moves.length, 'selected:', randomMove);
                                self.postMessage('bestmove ' + randomMove);
                            } catch (err) {
                                console.error('Move generation error:', err);
                                self.postMessage('bestmove e7e5');
                            }
                        }, 300 + Math.random() * 700);
                    }
                };
            `;
            
            const blob = new Blob([stockfishCode], { type: 'application/javascript' });
            const blobUrl = URL.createObjectURL(blob);
            console.info('Using inline Stockfish Worker with basic move generation');
            return new Worker(blobUrl);
        }

        // 页面骨架
        const h1 = document.createElement('h1'); h1.textContent = '国际象棋 - 在线对战（含AI）';
        const subtitle = document.createElement('div'); subtitle.className = 'subtitle'; subtitle.textContent = '完整规则 · 升变 · 将军/将死 · Stockfish AI';
        const container = document.createElement('div'); container.className = 'container';
        const board = document.createElement('div'); board.className = 'board';
        const side = document.createElement('div'); side.className = 'side';
        document.body.appendChild(h1); document.body.appendChild(subtitle); document.body.appendChild(container);
        container.appendChild(board); container.appendChild(side);
        side.innerHTML = ''+
        '<div class="row"><label>对手</label><select id="opponent"><option value="ai" selected>AI</option><option value="human">本地双人</option></select></div>'+
        '<div class="row"><label>你执</label><select id="side"><option value="w" selected>白</option><option value="b">黑</option></select></div>'+
        '<div class="row"><label>难度</label><select id="level"><option value="1">1</option><option value="5" selected>5</option><option value="10">10</option><option value="15">15</option><option value="20">20</option></select></div>'+
        '<div class="row"><label>深度</label><select id="depth"><option value="8">8</option><option value="10" selected>10</option><option value="12">12</option><option value="14">14</option><option value="18">18</option></select></div>'+
        '<div class="row" style="gap:10px; margin-top:4px;"><button id="new">新局</button><button id="undo">悔棋</button></div>'+
        '<div class="status" id="status">状态: 游戏中</div>'+
        '<div class="history"><h3>走子记录</h3><div class="list" id="moves"></div></div>';
        const promoMask = document.createElement('div'); promoMask.className = 'promo-mask';
        promoMask.innerHTML = '<div class="promo"><h4>升变为：</h4><div class="choices">\
            <span class="choice" data-q="q">♛</span>\
            <span class="choice" data-q="r">♜</span>\
            <span class="choice" data-q="b">♝</span>\
            <span class="choice" data-q="n">♞</span>\
        </div></div>';
        document.body.appendChild(promoMask);

        // 棋局与渲染
        // 使用经典国际象棋 SVG 图标（Wikimedia cburnett 套系），跨域图片可直接显示
        function pieceImageUrl(type, color) {
            const key = (color === 'w' ? type.toUpperCase() : type);
            const map = {
                P: 'https://upload.wikimedia.org/wikipedia/commons/4/45/Chess_plt45.svg',
                N: 'https://upload.wikimedia.org/wikipedia/commons/7/70/Chess_nlt45.svg',
                B: 'https://upload.wikimedia.org/wikipedia/commons/b/b1/Chess_blt45.svg',
                R: 'https://upload.wikimedia.org/wikipedia/commons/7/72/Chess_rlt45.svg',
                Q: 'https://upload.wikimedia.org/wikipedia/commons/1/15/Chess_qlt45.svg',
                K: 'https://upload.wikimedia.org/wikipedia/commons/4/42/Chess_klt45.svg',
                p: 'https://upload.wikimedia.org/wikipedia/commons/c/c7/Chess_pdt45.svg',
                n: 'https://upload.wikimedia.org/wikipedia/commons/e/ef/Chess_ndt45.svg',
                b: 'https://upload.wikimedia.org/wikipedia/commons/9/98/Chess_bdt45.svg',
                r: 'https://upload.wikimedia.org/wikipedia/commons/f/ff/Chess_rdt45.svg',
                q: 'https://upload.wikimedia.org/wikipedia/commons/4/47/Chess_qdt45.svg',
                k: 'https://upload.wikimedia.org/wikipedia/commons/f/f0/Chess_kdt45.svg'
            };
            return map[key];
        }
        const game = new Chess();
        const squares = [];
        for (let r = 0; r < 8; r++) {
            for (let c = 0; c < 8; c++) {
                const sq = document.createElement('div');
                sq.className = 'sq ' + ((r + c) % 2 === 0 ? 'light' : 'dark');
                sq.dataset.r = String(r); sq.dataset.c = String(c);
                board.appendChild(sq); squares.push(sq);
            }
        }
        function rcToSquare(r, c) { return 'abcdefgh'[c] + (8 - r); }
        function squareToRC(sq) { const rank = parseInt(sq[1], 10); return [8 - rank, sq.charCodeAt(0) - 97]; }
        function findKing(color) {
            const b = game.board();
            for (let r = 0; r < 8; r++) for (let c = 0; c < 8; c++) { const p=b[r][c]; if (p && p.type==='k' && p.color===color) return rcToSquare(r,c); }
            return null;
        }
        function render() {
            squares.forEach(s => { s.innerHTML=''; s.classList.remove('selected','mark','valid','capture','check'); });
            for (let r = 0; r < 8; r++) for (let c = 0; c < 8; c++) {
                const name = rcToSquare(r,c); const p = game.get(name);
                if (p) {
                    const img = document.createElement('img');
                    img.src = pieceImageUrl(p.type, p.color);
                    img.alt = p.type + p.color;
                    img.style.width = '86%';
                    img.style.height = '86%';
                    img.style.objectFit = 'contain';
                    squares[r*8+c].appendChild(img);
                }
            }
            if (game.inCheck()) { const k = findKing(game.turn()); if (k) { const [kr,kc]=squareToRC(k); squares[kr*8+kc].classList.add('check'); } }
            updateStatus(); renderMoves();
        }
        function renderMoves() {
            const list = document.getElementById('moves'); list.innerHTML='';
            const hist = game.history({ verbose: true });
            for (let i=0;i<hist.length;i+=2) { const w=hist[i], b=hist[i+1];
                const wEl=document.createElement('div'); wEl.textContent = `${i/2+1}. ${w? w.san: ''}`; list.appendChild(wEl);
                const bEl=document.createElement('div'); bEl.textContent = b? b.san: ''; list.appendChild(bEl);
            }
        }

        // 交互
        let selectedSq = null;
        function clearHighlights(){ squares.forEach(s=>s.classList.remove('selected','mark','valid','capture')); }
        function highlightMoves(from){
            const moves = game.moves({ square: from, verbose: true });
            for (const m of moves){ const [r,c]=squareToRC(m.to); const el = squares[r*8+c]; el.classList.add('mark', m.flags.includes('c') ? 'capture':'valid'); }
        }
        board.addEventListener('click', (e)=>{
            const target = e.target.closest('.sq'); if(!target) return;
            const r=parseInt(target.dataset.r,10), c=parseInt(target.dataset.c,10); const sq = rcToSquare(r,c);
            const opponent = document.getElementById('opponent').value;
            const humanColor = document.getElementById('side').value;
            const humanTurn = opponent==='human' || game.turn()===humanColor;
            if(!humanTurn) return;
            const piece = game.get(sq);
            if(selectedSq===sq){ selectedSq=null; clearHighlights(); return; }
            if(!selectedSq){ if(piece && piece.color===game.turn()){ selectedSq=sq; clearHighlights(); target.classList.add('selected'); highlightMoves(sq);} return; }
            const isPromotion = (game.get(selectedSq)?.type==='p') && ((game.turn()==='w' && sq.endsWith('8')) || (game.turn()==='b' && sq.endsWith('1')));
            if(isPromotion){ showPromotion().then(prom=>{ tryMove(selectedSq,sq,prom); }); } else { tryMove(selectedSq,sq,undefined); }
        });
        function tryMove(from,to,promotion){ const res = game.move({from,to,promotion}); if(res){ selectedSq=null; clearHighlights(); render(); maybeAIMove(); } }
        function showPromotion(){ return new Promise(resolve=>{ promoMask.style.display='grid';
            const onClick=(e)=>{ const el=e.target.closest('.choice'); if(!el) return; const q=el.getAttribute('data-q'); cleanup(); resolve(q); };
            function cleanup(){ promoMask.style.display='none'; promoMask.removeEventListener('click', onClick); }
            promoMask.addEventListener('click', onClick);
        }); }

        // 状态与按钮
        const statusEl = document.getElementById('status');
        function updateStatus(){ let t='状态: '; if(game.isCheckmate()) t+='将死'; else if(game.isDraw()) t+='和棋'; else if(game.inCheck()) t+='将军'; else t+='游戏中'; statusEl.textContent = t + ` · 轮到: ${game.turn()==='w'?'白':'黑'}`; }
        document.getElementById('new').onclick = ()=>{ game.reset(); render(); maybeAIMove(true); };
        document.getElementById('undo').onclick = ()=>{ game.undo(); game.undo(); render(); };
        document.getElementById('opponent').onchange = ()=>{ render(); maybeAIMove(true); };
        document.getElementById('side').onchange = ()=>{ game.reset(); render(); maybeAIMove(true); };

        // Stockfish 集成
        const engine = await createStockfishWorker();
        let uciReady = false;
        let readyForMove = false;
        
        engine.onmessage = (ev)=>{
            const line = typeof ev === 'string' ? ev : ev.data; if(typeof line !== 'string') return;
            console.log('Engine message:', line);
            if (line.indexOf('uciok') !== -1) {
                uciReady = true;
                console.log('UCI ready');
            }
            if (line.indexOf('readyok') !== -1) {
                readyForMove = true;
                console.log('Engine ready for move');
            }
            if(line.startsWith('bestmove')){ 
                console.log('Bestmove received:', line);
                const parts=line.split(' '); const mv=parts[1]; 
                if(mv && mv.length>=4){ 
                    const from=mv.slice(0,2), to=mv.slice(2,4), promo=mv[4]; 
                    console.log('AI move:', from, 'to', to, promo ? 'promote to ' + promo : '');
                    
                    // 验证走法是否合法
                    try {
                        const testGame = new Chess(game.fen());
                        const moveObj = {from, to};
                        if (promo) moveObj.promotion = promo;
                        const result = testGame.move(moveObj);
                        
                        if (result) {
                            // 走法合法，执行
                            tryMove(from, to, promo);
                            statusEl.textContent = '状态: 游戏中 · AI已走';
                        } else {
                            // 走法不合法，重新生成
                            console.warn('Invalid AI move, regenerating...');
                            engine.postMessage('go depth 1');
                        }
                    } catch (err) {
                        console.error('Move validation error:', err);
                        // 出错时重新生成
                        engine.postMessage('go depth 1');
                    }
                }
            }
        };
        
        // 简化初始化
        engine.postMessage('uci');
        setTimeout(() => {
            if (!uciReady) {
                console.log('UCI timeout, proceeding anyway');
                uciReady = true;
            }
        }, 2000);
        async function maybeAIMove(force=false){ 
            const opponent=document.getElementById('opponent').value; 
            const humanColor=document.getElementById('side').value; 
            const currentTurn = game.turn();
            const historyLength = game.history().length;
            
            console.log('maybeAIMove called:', { force, opponent, humanColor, currentTurn, historyLength, isGameOver: game.isGameOver() });
            
            if(opponent!=='ai') { console.log('Not AI opponent, skipping'); return; }
            if(game.isGameOver()) { console.log('Game over, skipping'); return; }
            if(!force && currentTurn===humanColor) { console.log('Human turn, skipping'); return; }
            
            // 初始化时仅当人执黑才让AI先走
            if (force && humanColor === 'w' && historyLength === 0) { 
                console.log('Human plays white, AI should not move first'); 
                return; 
            }
            
            console.log('AI should move now');
            const level=parseInt(document.getElementById('level').value,10); 
            let depth=parseInt(document.getElementById('depth').value,10);
            if (!Number.isFinite(depth) || depth > 14) depth = 10;
            const fen=game.fen();
            console.log('FEN:', fen, 'Level:', level, 'Depth:', depth);
            
            // 简化命令序列，不等待 readyok
            engine.postMessage('stop');
            engine.postMessage('ucinewgame');
            engine.postMessage(`setoption name Skill Level value ${level}`);
            engine.postMessage('setoption name UCI_Chess960 value false');
            engine.postMessage(`position fen ${fen}`);
            engine.postMessage(`go depth ${depth}`);
            console.log('Sent go command, waiting for bestmove...');
            statusEl.textContent='状态: AI思考中...'; 
        }

        // 初始渲染
        render(); maybeAIMove(true);
    </script>
</head>
<body></body>
</html>

